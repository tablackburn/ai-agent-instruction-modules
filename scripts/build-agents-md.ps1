<#
.SYNOPSIS
    Builds AGENTS.md from enabled instruction modules.

.DESCRIPTION
    This script generates a single AGENTS.md file by:
    1. Reading the aim.json configuration
    2. Collecting content from enabled modules
    3. Fetching cached fallback modules if applicable
    4. Composing everything into a single AGENTS.md file

.PARAMETER TargetPath
    The path to the target repository. Defaults to parent directory of .aim folder.

.EXAMPLE
    .\build-agents-md.ps1
    Builds AGENTS.md in the parent directory.

.EXAMPLE
    .\build-agents-md.ps1 -TargetPath "C:\Projects\MyRepo"
    Builds AGENTS.md in the specified directory.
#>
[CmdletBinding()]
param(
    [Parameter(Position = 0)]
    [string]$TargetPath
)

$ErrorActionPreference = 'Stop'

# Determine paths
$scriptRoot = $PSScriptRoot
$aimRoot = Split-Path -Parent $scriptRoot

if ([string]::IsNullOrEmpty($TargetPath)) {
    $TargetPath = Split-Path -Parent $aimRoot
}

$configFile = Join-Path $TargetPath 'aim.json'
$agentsFile = Join-Path $TargetPath 'AGENTS.md'
$instructionsPath = Join-Path $aimRoot 'instructions'
$cachePath = Join-Path $TargetPath '.aim-cache'

# Check for aim.json
if (-not (Test-Path $configFile)) {
    Write-Error "aim.json not found at $configFile. Run deploy.ps1 first."
    exit 1
}

# Load configuration
$config = Get-Content $configFile -Raw | ConvertFrom-Json -AsHashtable

# Get AIM version from CHANGELOG or default
$version = '0.1.0'
$changelogPath = Join-Path $aimRoot 'CHANGELOG.md'
if (Test-Path $changelogPath) {
    $changelogContent = Get-Content $changelogPath -Raw
    if ($changelogContent -match '\[(\d+\.\d+\.\d+)\]') {
        $version = $Matches[1]
    }
}

# Collect enabled modules
$enabledModules = @()
foreach ($moduleName in $config.modules.Keys | Sort-Object) {
    # Security: Validate module name format to prevent path injection
    if ($moduleName -notmatch '^[a-zA-Z0-9]+/[a-zA-Z0-9_-]+$') {
        Write-Warning "Security: Skipping invalid module name '$moduleName'. Module names must match pattern: category/module-name"
        continue
    }

    # Security: Additional check for path traversal attempts
    if ($moduleName -match '\.\.' -or $moduleName -match '^/' -or $moduleName -match '\\') {
        Write-Warning "Security: Skipping suspicious module name '$moduleName'. Path traversal sequences are not allowed."
        continue
    }

    $moduleValue = $config.modules[$moduleName]

    # Determine source: handle boolean, string, and object formats
    $source = $null
    if ($moduleValue -eq $true) {
        $source = 'local'
    }
    elseif ($moduleValue -eq 'awesome-copilot') {
        $source = 'awesome-copilot'
    }
    elseif ($moduleValue -is [hashtable] -and $moduleValue.source -eq 'awesome-copilot') {
        $source = 'awesome-copilot'
    }

    if ($source) {
        $enabledModules += @{
            Name = $moduleName
            Source = $source
        }
    }
}

if ($enabledModules.Count -eq 0) {
    Write-Warning 'No modules enabled in aim.json'
}

# Start building AGENTS.md content
$content = @()
$content += '# AI Agent Instructions'
$content += ''
$content += "> Auto-generated by [AIM](https://github.com/tablackburn/ai-agent-instruction-modules) v$version"
$content += "> Last sync: $(Get-Date -Format 'yyyy-MM-dd')"
$content += "> Enabled modules: $($enabledModules.Count)"
$content += ''

# Build table of contents
$content += '## Table of Contents'
$content += ''
foreach ($module in $enabledModules) {
    $displayName = ($module.Name -split '/')[-1]
    $displayName = (Get-Culture).TextInfo.ToTitleCase(($displayName -replace '-', ' '))
    $anchor = $displayName.ToLower() -replace ' ', '-'
    $content += "- [$displayName](#$anchor)"
}
$content += ''

# Add each module's content
foreach ($module in $enabledModules) {
    $moduleName = $module.Name
    $moduleSource = $module.Source

    $displayName = ($moduleName -split '/')[-1]
    $displayName = (Get-Culture).TextInfo.ToTitleCase(($displayName -replace '-', ' '))

    $content += '---'
    $content += ''
    $content += "## $displayName"
    $content += ''
    $content += "<!-- BEGIN: $moduleName -->"
    $content += ''

    # Get module content
    $moduleContent = $null

    if ($moduleSource -eq 'local') {
        $modulePath = Join-Path $instructionsPath "$moduleName.md"
        if (Test-Path $modulePath) {
            $moduleContent = Get-Content $modulePath -Raw

            # Strip YAML frontmatter if present
            if ($moduleContent -match '^---\r?\n[\s\S]*?\r?\n---\r?\n([\s\S]*)$') {
                $moduleContent = $Matches[1]
            }

            # Remove the first H1 header if it matches the module name
            $moduleContent = $moduleContent -replace "^#\s+$([regex]::Escape($displayName))\s*\r?\n", ''
        }
        else {
            $moduleContent = "*Module file not found: $modulePath*"
            Write-Warning "Module not found: $modulePath"
        }
    }
    elseif ($moduleSource -eq 'awesome-copilot') {
        $cacheFile = Join-Path $cachePath "$($moduleName -replace '/', '_').md"
        if (Test-Path $cacheFile) {
            $moduleContent = Get-Content $cacheFile -Raw

            # Strip YAML frontmatter if present
            if ($moduleContent -match '^---\r?\n[\s\S]*?\r?\n---\r?\n([\s\S]*)$') {
                $moduleContent = $Matches[1]
            }
        }
        else {
            $moduleContent = '*Fallback module not cached. Run sync.ps1 to fetch.*'
            Write-Warning "Fallback module not cached: $moduleName. Run sync.ps1 to fetch."
        }
    }

    $content += $moduleContent.Trim()
    $content += ''
    $content += "<!-- END: $moduleName -->"
    $content += ''
}

# Add custom instructions if specified
if ($config.customInstructionsPath) {
    $customPath = Join-Path $TargetPath $config.customInstructionsPath

    # Security: Validate path is within target directory (prevent path traversal attacks)
    $resolvedTarget = [System.IO.Path]::GetFullPath($TargetPath)
    $resolvedCustom = [System.IO.Path]::GetFullPath($customPath)

    # Use case-insensitive comparison on Windows, case-sensitive on Unix
    $pathComparison = if ($IsWindows -or $env:OS -match 'Windows') {
        [System.StringComparison]::OrdinalIgnoreCase
    } else {
        [System.StringComparison]::Ordinal
    }

    $targetWithSeparator = $resolvedTarget + [System.IO.Path]::DirectorySeparatorChar
    $isWithinTarget = $resolvedCustom.StartsWith($targetWithSeparator, $pathComparison) -or
                      $resolvedCustom.Equals($resolvedTarget, $pathComparison)

    if (-not $isWithinTarget) {
        Write-Warning "Security: Custom instructions path '$($config.customInstructionsPath)' is outside target directory. Skipping."
    }
    elseif (Test-Path $customPath) {
        $content += '---'
        $content += ''
        $content += '## Custom Instructions'
        $content += ''
        $content += '<!-- BEGIN: custom -->'
        $content += ''
        $customContent = Get-Content $customPath -Raw
        $content += $customContent.Trim()
        $content += ''
        $content += '<!-- END: custom -->'
        $content += ''
    }
}

# Write AGENTS.md
$finalContent = $content -join "`n"
Set-Content -Path $agentsFile -Value $finalContent -Encoding UTF8 -NoNewline

Write-Host "Generated: $agentsFile" -ForegroundColor Green
Write-Host "  Modules: $($enabledModules.Count)"
